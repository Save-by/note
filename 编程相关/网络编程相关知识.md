# 网络编程相关知识

> 仅个人笔记

## 1. 计网OSI

### 1.1 OSI七层模型

| OSI中的层  |                  功能                  |               TCP/IP协议族               |
| :--------: | :------------------------------------: | :--------------------------------------: |
|   应用层   | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet |
|   表示层   |     数据格式化，代码转换，数据加密     |                    无                    |
|   会话层   |       解除或建立与别的接点的联系       |                    无                    |
|   传输层   |            提供端对端的接口            |                 TCP，UDP                 |
|   网络层   |            为数据包选择路由            |      IP，ICMP，RIP，OSPF，BGP，IGMP      |
| 数据链路层 |     传输有地址的帧以及错误检测功能     |     SLIP，CSLIP，PPP，ARP，RARP，MTU     |
|   物理层   |  以二进制数据形式在物理媒体上传输数据  |       ISO2110，IEEE802，IEEE802.2        |

OSI是Open System Interconnect的缩写，意为开放式系统互联。

**OSI七层参考模型的各个层次的划分遵循下列原则：**

1. 同一层中的各网络节点都有相同的层次结构，具有同样的功能。
2. 同一节点内相邻层之间通过接口（可以是逻辑接口）进行通信。
3. 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。
4. 不同节点的同等层按照协议实现对等层之间的通信。



## 2. TCP/IP参考模型

### 2.1 TCP/IP五层模型的协议

|  TCP/IP层  |                           网络设备                           |
| :--------: | :----------------------------------------------------------: |
|   应用层   |                              --                              |
|   传输层   |                    四层交换机、四层路由器                    |
|   网络层   |                      路由器、三层交换机                      |
| 数据链路层 | 网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层） |
|   物理层   |     中继器、集线器、还有我们通常说的双绞线也工作在物理层     |

***（TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点）***



###  2.2 TCP与UDP

> **TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。**

1. **其中TCP提供IP环境下的数据可靠传输**，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复 用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送。

2. **而UDP则不为IP提供可靠性、 流控或差错恢复功能。**一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。

3. TCP支持的应用协议主要 有：Telnet、FTP、SMTP等。

   UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系 统）、TFTP（通用文件传输协议）等。



### 2.3 IP协议

> (引自百度百科)
>
> **IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网络层协议。**
>
> 设计IP的目的是提高网络的可扩展性：
>
> 1. 一是解决互联网问题，实现大规模、异构网络的互联互通.
>
> 2. 二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。
>
>    根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据报传输服务。
>
> 
>
> **IP是整个TCP/IP协议族的核心，也是构成互联网的基础。**IP位于TCP/IP模型的网络层(相当于OSI模型的网络层)，对上可载送传输层各种协议的信息，例如TCP、UDP等；对下可将IP信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。 
>
> 为了能适应异构网络，IP强调适应性、简洁性和可操作性，并在可靠性做了一定的牺牲。IP不保证分组的交付时限和可靠性，所传送分组有可能出现丢失、重复、延迟或乱序等问题。

#### 2.3.1 IP主要包含三方面内容：IP编址方案、分组封装格式及分组转发规则。

1. IP分组的转发规则

   路由器仅根据网络地址进行转发。当IP数据包经由路由器转发时，如果目标网络与本地路由器直接相连，则直接将数据包交付给目标主机，这称为直接交付；否则，路由器通过路由表查找路由信息，并将数据包转交给指明的下一跳路由器，这称为间接交付。路由器在间接交付中，若路由表中有到达目标网络的路由，则把数据包传送给路由表指明的下一跳路由器；如果没有路由，但路由表中有一个默认路由，则把数据报传送给指明的默认路由器；如果两者都没有，则丢弃数据包并报告错误。

2. IP分片

   一个IP包从源主机传输到目标主机可能需要经过多个不同的物理网络。由于各种网络的数据帧都有一个最大传输单元MTU的限制，如以太网帧的MTU是1500；因此，当路由器在转发IP包时，如果数据包的大小超过了出口链路的最大传输单元时，则会将该IP分组分解成很多足够小的片段，以便能够在目标链路上进行传输。这些IP分片重新封装一个IP包独立传输，并在到达目标主机时才会被重组起来。 

3. IP分组结构

   一个IP分组由首部和数据两部分组成。首部的前20字节是所有IP分组必须具有的，也称固定首部。在首部固定部分的后面是一些可选字段，其长度是可变的。

#### 2.3.2 IP所提供的服务大致可归纳为两类： IP信息包的传送、IP信息包的分割与重组

##### 2.3.2.1 IP信息包的传送

IP是网络之间信息传送的协议，可将IP信息包从源设备(例如用户的计算机)传送到目的设备(例如某部门的www服务器)。为了达到这样的目的，IP必须依赖IP地址与IP路由器两种机制来实现。

1. IP地址

IP规定**网络上所有的设备都必须有一个独一无二的IP地址**，就好比是邮件上都必须注明收件人地址，邮递员才能将邮件送到。同理，每个IP信息包都必须包含有目的设备的IP地址，信息包才可以正确地送到目的地。同一设备不可以拥有多个IP地址，所有使用IP的网络设备至少有一个唯一的IP地址。

2. IP路由

互联网是由许多个网络连接所形成的大型网络。**如果要在互联网中传送IP信息包，除了确保网络上每个设备都有一个唯一的IP地址之外，网络之间还必须有传送的机制，才能将IP信息包通过一个个的网络传送到目的地。此种传送机制称为IP路由。**

各个网络通过路由器相互连接。**路由器的功能是为IP信息包选择传送的路径**。换言之，必须依靠沿途各路由器的通力合作，才能将IP信息包送到目的地。在IP路由的过程中，由路由器负责选择路径，IP信息包则是被传送的对象。



IP地址与IP路由是IP信息包传送的基础。此外，**IP信息包传送时还有一项很重要的特性，即使用非连接式的传送方式**。非连接式的传送方式是指IP信息包传送时，**源设备与目的设备双方不必事先连接，即可将IP信息包送达。即源设备完全不用理会目的设备，而只是单纯地将IP信息包逐一送出。**至于目的设备是否收到每个信息包、是否收到正确的信息包等，则由上层的协议(例如TCP)来负责检查。



使用非连接式的优点是过程简单化，可提高传输的效率。此外，由于IP信息包必须通过IP路由的机制，在一个个路由器之间传递，非连接式的传送方式较易在此种机制中运行。



相对于非连接式的传送方式，也有连接式的传送方式，也就是源与目的设备双方必须先建立连接，才能进一步传输数据，TCP就是使用连接式的传送方式。



##### 2.3.2.2 IP信息包的分割与重组

为了能把一个IP报文放在不同的物理帧中，最大IP报文的长度就只能等于这条路径上所有物理网络的MTU的最小值。当数据报通过一个可以传输长度更大的帧的网络时，把数据报的大小限制在互联网上最小的MTU之下不经济；如果数据报的长度超过互联网中最小的MTU值的话，则当该数据报在穿越该子网时，就无法被封装在一个帧中。



IP协议在发送IP报文时，一般选择一个合适的初始长度。如果这个报文要经历的中间物理网络的MTU值比IP报文长度要小，则IP协议把这个报文的数据部分分割成若干个较小的数据片，组成较小的报文，然后放到物理帧中去发送。每个小的报文称为一个分段。分段的动作一般在路由器上进行。如果路由器从某个网络接口收到了一个IP报文，要向另外一个网络转发，而该网络的MTU比IP报文长度要小，那么就要把该IP报文分成多个小IP分段后再分别发送。 



重组是分段的逆过程，把若干个IP分段重新组合后还原为原来的IP报文。在目的端收到一个IP报文时，可以根据其分段偏移和MF标志位来判断它是否是一个分段。如果MF位是0，并且分段偏移为0，则表明这是一个完整的IP数据报。否则，如果分段偏移不为0，或者MF标志位为1，则表明它是一个分段。这时目的地端需要实行分段重组。IP协议根据IP报文头中的标识符字段的值来确定哪些分段属于同一个原始报文，根据分段偏移来确定分段在原始报文中的位置。如果一个IP数据报的所有分段都正确地到达目的地，则把它重新组织成一个完整的报文后交给上层协议去处理。 



总结如下：IP信息包在传送过程中，可能会经过许多个使用不同技术的网络。假设IP信息包是从ATM网络所发出，原始长度为9180B，如果IP路由途中经过以太网络，便面临信息包太大，无法在以太网络上传输的障碍。为了解决此问题，路由器必须有IP信息包分割与重组的机制，将过长的信息包进行分割，以便能在最大传输单位较小的网络上传输。分割后的IP信息包，由目的设备接收后重组，恢复成原来IP信息包。



#### 2.3.3 IP信息包的传送方式

在传送IP信息包时，一定会指明源地址与目的地址。**源地址当然只有一个，但是目的地址却可能代表单一或多部设备。**根据目的地址的不同，**区分为3种传送方式：单点传送、广播传送以及多点传送**。



##### 2.3.3.1 单点传送

**单点传送是一对一的传递模式。**在此模式下，源端所发出的IP信息包，其IP报头中的目的地址代表单一目的设备，因此只有该目的设备能收到此IP信息包。在互联网上传送的信息包，绝大多数都是单点传送的IP信息包。

##### 2.3.3.2 广播传送

**广播传送是一对多的传递方式。**在此方式下，源设备所发出的IP信息包，其IP报头中的目的地址代表某一网络，而非单一设备，因此该网络内的所有设备都能收到、并处理此类IP广播信息包。由于此特性，广播信息包必须小心使用，否则稍有不慎，便会波及该网络内的全部设备。

##### 2.3.3.3 多点传送

**多点传送是一种介于单点传送与广播传送之间的传送方式模式。多点传送也是属于一对多的传送方式，但是它与广播传送有很大的不同。**广播传送必定会传送至某一个网络内的所有设备，但是多点传送却可以将信息包传送给一群指定的设备。即多点传送的IP信息包，其IP报头中的目的地址代表的是一群选定的设备。凡是属于这一群的设备都可收到此多点传送信息包。

设置多点传送方式的原因是：假设我们要必须传送一份数据给网络上10部指定的设备。如果使用单点传送的方式，必须重复执行10次传送的操作才能达成目的，不仅没有效率，且浪费网络带宽。如果使用广播传送的方式，则指定网络中的所有(例如20部)计算机都会收到、且必须处理这些广播传送信息包，换言之，将影响到其他不相干的计算机。这时候，如果使用多点传送，便能避免单点传送与广播传送的问题。

多点传送非常适合传送一些即时共享的信息给一群用户，例如传送即时股价、多媒体影音信息等。不过，虽然在同一个网络内进行多点传送没有技术上的问题，但如果要通过互联网，则沿途的路由器必须都支持相关的协议才行，这也是多点传送所面临的瓶颈。



#### 2.3.4 协议版本

##### 2.3.4.1 IPv4协议

网际协议第4版（Internet Protocol version4，IPv4）是TCP/IP协议使用的数据报传输机制。数据报是一个可变长分组，有两部分组成：头部和数据。头部长度可由20~60个字节组成，该部分包含有与路由选择和传输有关的重要信息。头部各字段意义按顺序如下：



1. **版本（4位）**：该字段定义IP协议版本，负责向处理机所运行的IP软件指明此IP数据报是哪个版本，所有字段都要按照此版本的协议来解释。如果计算机使用其他版本，则丢弃数据报。



2. **头部长度（4位）**：该字段定义数据报协议头长度，表示协议头部具有32位字长的数量。协议头最小值为5，最大值为15。



3. **服务（8位）**：该字段定义上层协议对处理当前数据报所期望的服务质量，并对数据报按照重要性级别进行分配。前3位成为优先位，后面4位成为服务类型，最后1位没有定义。这些8位字段用于分配优先级、延迟、吞吐量以及可靠性。



4. **总长度（16位）**：该字段定义整个IP数据报的字节长度，包括协议头部和数据。其最大值为65535字节。以太网协议对能够封装在一个帧中的数据有最小值和最大值的限制（46~1500个字节）。



5. **标识（16位）**：该字段包含一个整数，用于识别当前数据报。当数据报分段时，标识字段的值被复制到所有的分段之中。该字段由发送端分配帮助接收端集中数据报分段。



6. **标记（3位）**：该字段由3位字段构成，其中最低位（MF）控制分段，存在下一个分段置为1，否则置0代表该分段是最后一个分段。中间位（DF）指出数据报是否可进行分段，如果为1则机器不能将该数据报进行分段。第三位即最高位保留不使用，值为0。



7. **分段偏移（13位）**：该字段指出分段数据在源数据报中的相对位置，支持目标IP适当重建源数据。



8. **生存时间（8位）**：该字段是一种计数器，在丢弃数据报的每个点值依次减1直至减少为0。这样确保数据报拥有有限的环路过程（即TTL），限制了数据报的寿命。



9. **协议（8位）**：该字段指出在IP处理过程完成之后，有哪种上层协议接收导入数据报。这个字段的值对接收方的网络层了解数据属于哪个协议很有帮助。 



10. **头部校验和（16位）**：该字段帮助确保IP协议头的完整性。由于某些协议头字段的改变，这就需要对每个点重新计算和检验。计算过程是先将校验和字段置为0，然后将整个头部每16位划分为一部分，将个部分相加，再将计算结果取反码，插入到校验和字段中。



11. **源地址（32位）**：源主机IP地址，该字段在IPv4数据报从源主机到目的主机传输期间必须保持不变。



12. **目的地址（32位）**：目标主机IP地址，该字段在IPv4数据报从源主机到目的主机传输期间同样必须保持不变。





##### 2.3.4.2 IPv6协议

自从1970年代IPv4问世以来，数据通信技术日新月异有了很大发展。虽然IPv4设计得很好，但其**缺点也逐渐显露出来**：

- 虽说借助子网化、无类寻址和NAT技术可以提高IP地址使用效率，**因特网中IP地址的耗尽**仍然是一个没有彻底解决的问题；

- **IPv4没有提供对实时音频和视频传输这种要求传输最小时延的策略和预留资源支持**；

- **IPv4不能对某些有数据加密和鉴别要求的应用提供支持**。

为了克服这些缺点，IPv6（Internet working Protocol version6）被提了出来。在IPv6中，IP地址格式和分组长度以及分组的格式都改变了。IPv6每个分组由必须的基本头部和其后的有效载荷组成。有效载荷由可选的扩展头部和来自上层的数据组成。基本头部占用40字节，有效载荷可以包含65535字节数据。IPv6头部各字段意义按顺序如下：



1. **版本（4位）**：该字段定义IPv6协议版本，其值为6，负责向处理机所运行的IP软件指明此IP数据报是IPv6版本。 



2. **优先级（4位）**：该字段定义当发生通信拥塞时的分组的优先级。



3. **流标号（24位）**：该字段用来对特殊的数据流提供专门处理。



4. **有效载荷长度（16位）**：该字段定义整个IPv6数据报的字节长度，包括基本头部和有效载荷。其最大值为65，535字节。 



5. **下一个头部（8位）**：该字段定义了数据报中跟随在基本头部之后的头部。下一个头部可以是IP所使用的可选扩展头部，也可以是上层协议的头部。 



6. **条数限制（8位）**：该字段与IPv4中生存时间（TTL）字段一样是一种计数器，在丢弃数据报的每个点值依次减1直至减少为0。



7. **源地址（128位）**：源主机IP地址，该字段在IPv4数据报从源主机到目的主机传输期间必须保持不变。



8. **目的地址（128位）**：目标主机IP地址，该字段在IPv4数据报从源主机到目的主机传输期间同样必须保持不变。



9. **扩展头部**：该字段包含6个可选类型，包括逐跳选项、源路由选择、分段、鉴别、加密的安全有效载荷、目的端选项。



#### 2.3.5 IP地址

##### 2.3.5.1 IP地址的结构

IP地址是用来识别网络上的设备，因此，IP地址是由网络地址与主机地址两部分所组成。

1. 网络地址

   网络地址可用来识别设备所在的网络，网络地址位于IP地址的前段。当组织或企业申请IP地址时，所获得的并非IP地址，而是取得一个唯一的、能够识别的网络地址。同一网络上的所有设备，都有相同的网络地址。IP路由的功能是根据IP地址中的网络地址，决定要将IP信息包送至所指明的那个网络。 

   

2. 主机地址

   主机地址位于IP地址的后段，可用来识别网络上设备。同一网络上的设备都会有相同的网络地址，而各设备之间则是以主机地址来区别。 

   由于各个网络的规模大小不一，大型的网络应该使用较短的网络地址，以便能使用较多的主机地址；反之，较小的网络则应该使用较长的网络地址。为了符合不同网络规模的需求，IP在设计时便根据网络地址的长度，设计与划分IP地址。

##### 2.3.5.2 五种地址等级

在设计IP时，着眼于路由与管理上的需求，因此制定了5种IP地址的等级。不过，一般最常用到的便是A、B、C类这三种等级的IP地址。5种等级分别使用不同长度的网络地址，因此适用于大、中，小型网络。IP地址的管理机构可根据申请者的网络规模，决定要赋予哪种等级。

***（传统IP地址的运行方式，由于以等级来划分，因此称为等级式的划分方式。相对的，后来又产生了无等级的划分方式，也就时CIDR）***

##### 2.3.5.3 特殊的IP地址

> 在实际应用上，有些网络地址与主机地址有特别的用途，因此在分配或管理IP地址时，要特别注意这些限制。

1. 广播地扯

   所有主机号部分为1的地址是广播地址。广播地址分为两种：直接广播地址和有限广播地址。

   在一特定子网中，主机地址部分为全I的地址称为直接广播地址。一台主机使用直接广播地址，可以向任何指定的网络直接广播它的数据报，很多IP协议利用这个功能向一个子网上广播数据。 

   32个比特全为l的IP地址(即255.255.255.255)被称为有限广播地址或本地网广播地址，该地址被用作在本网络内部广播。使用有限广播地址，主机在不知道自己的网络地址的情况下，也可以向本子网上所有的其他主机发送消息。

   广播地址不像其他的IP地址那样分配给某台具体的主机。因为它是指满足一定条件的一组计算机。广播地址只能作为IP报文的目的地址，表示该报文的一组接收者。

2. 组播地址

   D类IP地址就是组播地址，即在224.0.0.0~239.255.255.255范围内的每个IP地址，实际上代表一组特定的主机。 

   组播地址与广播地址相似之处是都只能作为IP报文的目的地址，表示该报文的一组接收者，而不能把它分配给某台具体的主机。

   组播地址和广播地址的区别在于广播地址是按主机的物理位置来划分各组的(属于同一个子网)，而组播地址指定一个逻辑组，参与该组的计算机可能遍布整个Internet。组播地址主要用于电视会议、视频点播等应用。 

   网络中的路由器根据参与的主机位置，为该组播的通信组形成一棵发送树。服务器在发送数据时，只需发送一份数据报文，该报文的目的地址为相应的组播地址。路由器根据已经形成的发送树依次转发，只是在树的分岔点处复制数据报，向多个网络转发一份副本。经过多个路由器的转发后，则该数据报可以到达所有登记到该组的主机处。这样就大大减少了源端主机的负担和网络资源的浪费。

3. 0地址

   主机号为0的IP地址从来不分配给任何-一个单个的主机号为0，例如，202.112.7.0就是--个典型的C类网络地址，表示该网络本身。 

   网络号为0的IP地址是指本网络上的某台主机。例如如果一台主机(IP地址为202.112.7.13)接收到一个IP报文，它的目的地址中网络号部分为0，而主机号部分与它自己的地址匹配(即IP地址为0.0.0.13)，则接收方把该IP地址解释成为本网络的主机地址，并接收该IP数据报。

   0.0.0.0代表本主机地址。网络上任何主机都可以用它来表示自己。

4. 回送地址

   原本属于A类地址范围内的IP地址127.0.0.0~127.255.255.255却并没有包含在A类地址之内。 

   任何一个以数字127开头的IP地址(127.x.x.x)都叫做回送地址。它是一个保留地址，最常见的表示形式为127.0.0.1。

   在每个主机上对应于IP地址127.0.0.1有个接口，称为回送接口。IP协议规定，当任何程序用回送地址作为目的地址时，计算机上的协议软件不会把该数据报向网络上发送，而是把数据直接返回给本主机。因此网络号等于127的数据报文不能出现于任何网络上，主机和路由器不能为该地址广播任何寻径信息。回送地址的用途是，可以实现对本机网络协议的测试或实现本地进程间的通信。



### 2.4 HTTP协议

> **HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。**
>
> HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
>
> HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
>
> HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。

#### 2.4.1 主要特点

1. **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

2. **灵活**：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

3. **无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

4. **无状态**：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5. **支持B/S及C/S模式**。

#### 2.4.2 URL

>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。
>
>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。

以下面这个URL为例，介绍下普通URL的各部分组成：

(http://www.ohhh.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name)

从上面的URL可以看出，一个完整的URL包括以下几部分：

1. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2. 域名部分：该URL的域名部分为“www.ohhh.com”。一个URL中，也可以使用IP地址作为域名使用

3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6. 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

> （详解URL的组成原文：http://blog.csdn.net/ergouge/article/details/8185219 ）

#### 2.4.3 URI和URL的区别

##### 2.4.3.1 URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。

Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
URI一般由三部组成：

1. 访问资源的命名机制
2. 存放资源的主机名
3. 资源自身的名称，由路径表示，着重强调于资源。



##### 2.4.3.2 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：

1. 协议(或称为服务方式)
2. 存有该资源的主机IP地址(有时也包括端口号)
3. 主机资源的具体地址。如目录和文件名等



##### 2.4.3.3 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。

URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

在java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。
在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。
相反的是，URL类可以打开一个到达资源的流。

#### 2.4.4 请求消息Request

>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：
>
>**请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。**

![img](https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2)

1. 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.

2. 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息

3. 第三部分：空行，请求头部后面的空行是必须的（**即使第四部分的请求数据为空，也必须有空行。**）

4. 第四部分：请求数据也叫主体，可以添加任意的其他数据。



#### 2.4.5 响应消息Response

>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。
>
>**HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。**



![img](https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2)

1. 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。

2. 第二部分：消息报头，用来说明客户端要使用的一些附加信息。

3. 第三部分：空行，消息报头后面的空行是必须的。

4. 第四部分：响应正文，服务器返回给客户端的文本信息。



#### 2.4.6 状态码

>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
>
>**1xx：指示信息--表示请求已接收，继续处理**
>
>**2xx：成功--表示请求已被成功接收、理解、接受**
>
>**3xx：重定向--要完成请求必须进行更进一步的操作**
>
>**4xx：客户端错误--请求有语法错误或请求无法实现**
>
>**5xx：服务器端错误--服务器未能实现合法的请求**

常见状态码：

|          状态码           |                             状态                             |
| :-----------------------: | :----------------------------------------------------------: |
|          200 OK           |                        客户端请求成功                        |
|      400 Bad Request      |           客户端请求有语法错误，不能被服务器所理解           |
|     401 Unauthorized      | 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 |
|       403 Forbidden       |               服务器收到请求，但是拒绝提供服务               |
|       404 Not Found       |             请求资源不存在，eg：输入了错误的URL              |
| 500 Internal Server Error |                   服务器发生不可预期的错误                   |
|  503 Server Unavailable   |    服务器当前不能处理客户端的请求，一段时间后可能恢复正常    |

>（更多状态码http://www.runoob.com/http/http-status-codes.html）

#### 2.4.7 HTTP请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

```http
GET      	//请求指定的页面信息，并返回实体主体。
HEAD     	//类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     	//向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT      	//从客户端向服务器传送的数据取代指定的文档的内容。
DELETE      //请求服务器删除指定的页面。
CONNECT     //HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     //允许客户端查看服务器的性能。
TRACE     	//回显服务器收到的请求，主要用于测试或诊断。
```



#### 2.4.8 HTTP工作原理

> HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP 请求/响应的步骤：

1. 客户端连接到Web服务器
2. 发送HTTP请求
3. 服务器接受请求并返回HTTP响应
4. 释放连接TCP连接
5. 客户端浏览器解析HTML内容





## 3. RESTFUL设计架构

>（引自菜鸟教程）
>
>**REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。** 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到："我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。**REST指的是一组架构约束条件和原则。" 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。**
>
>REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。

### 3.1 理解RESTful

要理解RESTful架构，需要理解Representational State Transfer这个词组到底是什么意思，它的每一个词都有些什么涵义。

 下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。

- 资源与URI
- 统一资源接口
- 资源的表述
- 资源的链接
- 状态的转移

#### 3.1.1 资源与URI

REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：

- 某用户的手机号码
- 某用户的个人信息
- 最多用户订购的GPRS套餐
- 两个产品之间的依赖关系
- 某用户可以办理的优惠套餐
- 某手机号码的潜在价值

要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。 

URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI：

- https://github.com/git
- https://github.com/git/git
- https://github.com/git/git/blob/master/block-sha1/sha1.h
- https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08
- https://github.com/git/git/pulls
- https://github.com/git/git/pulls?state=closed
- https://github.com/git/git/compare/master…next

下面让我们来看看URI设计上的一些技巧:

- 使用_或-来让URI可读性更好

曾经Web上的URI都是冰冷的数字或者无意义的字符串，但现在越来越多的网站使用_或-来分隔一些单词，让URI看上去更为人性化。 例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格， 如http://www.oschina.net/news/38119/oschina-translate-reward-plan。

- 使用/来表示资源的层级关系

例如上述/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源， 指的是git用户的git项目的某次提交记录，又例如/orders/2012/10可以用来表示2012年10月的订单记录。

- 使用?用来过滤资源

很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。

- ,或;可以用来表示同级资源的关系

有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git /block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如/git/git/compare/master…next。

#### 3.1.2 统一资源接口

RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。 

如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。 

#### 3.1.3 一些实践中常见的问题:

- POST和PUT用于创建资源时有什么区别?

POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。

 我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。

- 客户端不一定都支持这些HTTP方法吧?

的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法。 

在实践上，客户端和服务端都可能需要做一些妥协。例如rails框架就支持通过隐藏参数_method=DELETE来传递真实的请求方法， 而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。

- 统一接口是否意味着不能扩展带特殊语义的方法?

统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。 

像WebDAV就对HTTP方法进行了扩展，增加了LOCK、UPLOCK等方法。而github的API则支持使用PATCH方法来进行issue的更新，例如:

```http
PATCH /repos/:owner/:repo/issues/:number
```

不过，需要注意的是，像PATCH这种不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题。

- 统一资源接口对URI有什么指导意义?

统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。

 通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:

- GET /getUser/1
- POST /createUser
- PUT /updateUser/1
- DELETE /deleteUser/1

如果GET请求增加计数器，这是否违反安全性? 

安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。 

但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端"自作主张"的。

另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。

- 直接忽视缓存可取吗?

即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。 

对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。

- 响应代码的处理有必要吗?

HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。

例如，201（"Created"）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。 

假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。

 如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。

#### 3.1.4 资源的表述

上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。

 资源的表述包括数据和描述数据的元数据，例如，HTTP头"Content-Type" 就是这样一个元数据属性。 

那么客户端如何知道服务端提供哪种表述形式呢? 

答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。 

##### 3.1.4.1 在URI里边带上版本号

有些API在URI里边带上版本号，例如:

- http://api.example.com/1.0/foo
- http://api.example.com/1.2/foo
- http://api.example.com/2.0/foo

如果把版本号理解成资源的不同表述形式的话，就应该只是用一个URL，并通过Accept头部来区分，还是以github为例，它的Accept的完整格式是:application/vnd.github[.version].param[+json] 

对于v3版本的话，就是Accept: application/vnd.github.v3。对于上面的例子，同理可以使用使用下面的头部:

- Accept: vnd.example-com.foo+json; version=1.0
- Accept: vnd.example-com.foo+json; version=1.2
- Accept: vnd.example-com.foo+json; version=2.0

##### 3.1.4.2 使用URI后缀来区分表述格式

像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用内容协商来区分表述格式。 

##### 3.1.4.3 如何处理不支持的表述格式

当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。

#### 3.1.5 资源的链接

我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。 

这种反模式忽略了一个核心概念："超媒体即应用状态引擎（hypermedia as the engine of application state）"。 超媒体是什么? 

当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.

要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。

很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于"资源的CRUD"。

#### 3.1.6 状态的转移

有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。 

不过，我们先来讨论一下REST原则中的无状态通信原则。初看一下，好像自相矛盾了，既然无状态，何来状态转移一说? 

其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。 

##### 3.1.6.1 应用状态与资源状态

实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。 

客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。  

服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。 

 这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。  

在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。 

但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。  

这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。  

当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。 

##### 3.1.6.2 应用状态的转移

状态转移到这里已经很好理解了， "会话"状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。 

这些类似"下一页"之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。 

### 3.2 总结

现在广东XXX版本、XXX等项目中均使用传统的RPC、SOAP方式的Web服务，而移动南方基地XXXX项目的后台， 虽然采用了JSON格式进行交互，但还是属于RPC风格的。本文从资源的定义、获取、表述、关联、状态变迁等角度， 试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同。





## 4. IO阻塞与非阻塞的主要问题

> 有人把阻塞认为是同步，把非阻塞认为是异步；个人认为这样是不准确的，当然从思想上可以这样类比，但方式是完全不同的
>
> 在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种

### 4.1 阻塞IO与非阻塞IO有的区别与优缺点

在阻塞模式下，若从网络流中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，已知后面会有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就在那傻傻地等到下一个字节的到来，对，就在那等着，啥事也不做，直到把这10个字节读取完，这才将阻塞放开通行。

在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，已知后面会有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节再来的时候再去读取。



从上面可以看出，阻塞IO在性能方面是很低下的，如果要使用阻塞IO完成一个Web服务器的话，那么对于每一个请求都必须启用一个线程进行处理。而使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞，好比一下接收A请求的数据，另一下接收B请求的数据，等等，就是不停地东奔西跑，直接到把数据接收完了。

**虽然说，非阻塞IO比阻塞IO有更高的性能，但是对于开发来的，难度就成数倍递增了。由于是有多少数据就读取多少数据，这样在读取完整之前需要将已经读取到的数据保存起来，而且需要与其他地方来的数据隔离开来不能混在一起，否则就不知道这数据是谁的了**



#### 4.1.1 区别:
##### 4.1.1.1 读:
读本质来说其实不能是读,在实际中, 具体的接收数据不是由这些调用来进行，是由于系统底层自动完成的。read也好，recv也好只负责把数据从底层缓冲copy到我们指定的位置。

1. **在阻塞条件下，**如果没有发现数据在网络缓冲中会一直等待，当发现有数据的时候会把数据读到用户指定的缓冲区。但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read并不会一直等待下去，而是立刻返回。read的原则是数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。所以一般情况下我们读取数据都需要采用循环读的方式读取数据，一次read完毕不能保证读到我们需要长度的数据，read完一次需要判断读到的数据长度再决定是否还需要再次读取。

   

2. **在非阻塞的情况下，**read的行为是如果发现没有数据就直接返回，如果发现有数据那么也是采用有多少读多少的进行处理．对于读而言，**阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回。**
   recv中有一个MSG_WAITALL的参数　recv(sockfd, buff, buff_size, MSG_WAITALL)。在正常情况下　recv是会等待直到读取到buff_size长度的数据，但是这里的WAITALL也只是尽量读全，在有中断的情况下recv还是可能会被打断，造成没有读完指定的buff_size的长度。所以即使是采用recv + WAITALL参数还是要考虑是否需要循环读取的问题，在实验中对于多数情况下recv还是可以读完buff_size，所以相应的性能会比直接read进行循环读要好一些。不过要注意的是这个时候的sockfd必须是处于阻塞模式下，否则WAITALL不能起作用。


##### 4.1.1.2 写:
写的本质也不是进行发送操作，而是把用户态的数据copy到系统底层去，然后再由系统进行发送操作，返回成功只表示数据已经copy到底层缓冲，而不表示数据以及发出,更不能表示对端已经接收到数据。

1. **在阻塞的情况，**是会一直等待直到write完全部的数据再返回。这点行为上与读操作有所不同，究其原因主要是读数据的时候，通常刚开始我们并不知道要读的数据的长度，而是在数据的头部设置了一个长度，在读完指定长度的头部后，才知道整个要读的数据长度。如果一开始就贸然设置一个要读的数据长度，然后像阻塞的write那样去等读完，则很可能会造成死循环；而对于write，由于需要写的长度是已知的，所以可以一直再写，直到写完．不过问题是write是可能被打断造成write一次只write一部分数据，所以write的过程还是需要考虑循环write， 只不过多数情况下一次write调用就可能成功。
   　　

2. **非阻塞写的情况**，是采用可以写多少就写多少的策略。与读不一样的地方在于，有多少读多少是由网络发送端是否有数据传输到本地内核缓存为准。但是对于可以写多少是由本地的网络堵塞情况为标准的，在网络阻塞严重的时候，网络层没有足够的内存来进行写操作，这时候就会出现写不成功的情况，阻塞情况下会尽可能(有可能被中断)等待到数据全部发送完毕，对于非阻塞的情况就是一次写多少算多少,没有中断的情况下也还是会出现write到一部分的情况。